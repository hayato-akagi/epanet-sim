import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import numpy as np


def render_training_progress(steps_df, episodes_df):
    """å­¦ç¿’é€²è¡ŒçŠ¶æ³ã‚’å¯è¦–åŒ–"""
    
    st.header("Training Progress")
    
    if steps_df is None and episodes_df is None:
        st.info("No training logs available. This tab shows learning curves for VLA experiments.")
        st.markdown("""
        **Expected files:**
        - `training_steps.csv` - Step-by-step training data
        - `training_episodes.csv` - Episode-level statistics
        
        These files are automatically generated by controller-vla during training.
        """)
        return
    
    # ã‚µãƒžãƒªãƒ¼çµ±è¨ˆ
    render_training_summary(steps_df, episodes_df)
    
    # ã‚¿ãƒ–ã§åˆ†å‰²
    if steps_df is not None and episodes_df is not None:
        tab1, tab2, tab3 = st.tabs(["ðŸ“ˆ Learning Curves", "ðŸ“Š Episode Analysis", "ðŸ” Detailed Metrics"])
        
        with tab1:
            render_learning_curves(steps_df)
        
        with tab2:
            render_episode_analysis(episodes_df)
        
        with tab3:
            render_detailed_metrics(steps_df, episodes_df)
    
    elif steps_df is not None:
        render_learning_curves(steps_df)
    
    elif episodes_df is not None:
        render_episode_analysis(episodes_df)


def render_training_summary(steps_df, episodes_df):
    """å­¦ç¿’ã®æ¦‚è¦çµ±è¨ˆã‚’è¡¨ç¤º"""
    st.subheader("Training Summary")
    
    col1, col2, col3, col4, col5 = st.columns(5)
    
    if steps_df is not None and len(steps_df) > 0:
        total_steps = steps_df['total_steps'].max()
        episodes = steps_df['episode'].max()
        mean_reward = steps_df['reward'].mean()
        final_reward = steps_df['reward'].tail(100).mean()
        buffer_size = steps_df['buffer_size'].iloc[-1] if 'buffer_size' in steps_df.columns else 0
        
        col1.metric("Total Steps", f"{total_steps:,}")
        col2.metric("Episodes", f"{episodes}")
        col3.metric("Mean Reward", f"{mean_reward:.3f}")
        col4.metric("Recent Reward (last 100)", f"{final_reward:.3f}")
        col5.metric("Buffer Size", f"{buffer_size:,}")
    
    if episodes_df is not None and len(episodes_df) > 0:
        st.markdown("---")
        
        col1, col2, col3, col4 = st.columns(4)
        
        best_reward = episodes_df['episode_reward'].max()
        best_mae = episodes_df['mae'].min()
        final_mae = episodes_df['mae'].iloc[-1]
        improvement = ((episodes_df['mae'].iloc[0] - final_mae) / episodes_df['mae'].iloc[0] * 100) if len(episodes_df) > 0 and episodes_df['mae'].iloc[0] > 0 else 0
        
        col1.metric("Best Episode Reward", f"{best_reward:.3f}")
        col2.metric("Best MAE", f"{best_mae:.3f} m")
        col3.metric("Final MAE", f"{final_mae:.3f} m")
        col4.metric("MAE Improvement", f"{improvement:.1f}%")
    elif episodes_df is None or len(episodes_df) == 0:
        st.info("ðŸ“Š Episode statistics will appear here after completing at least one episode.")



def render_learning_curves(steps_df):
    """å­¦ç¿’æ›²ç·šã‚’è¡¨ç¤º"""
    st.subheader("Learning Curves (Step-by-Step)")
    
    # DataFrameãŒç©ºã®å ´åˆ
    if steps_df is None or len(steps_df) == 0:
        st.info("ðŸ“ˆ Learning curves will appear here as training progresses.")
        st.markdown("""
        **What you'll see here:**
        - Reward progression with moving averages
        - Reward components breakdown
        - Actor and Critic loss curves
        - Q-value evolution
        - Buffer size growth
        - Tracking error
        - Valve action magnitude
        """)
        return
    
    # ç§»å‹•å¹³å‡ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’é¸æŠž
    max_window = min(500, len(steps_df) // 2) if len(steps_df) > 20 else 10
    default_window = min(100, len(steps_df) // 3) if len(steps_df) > 30 else 10
    
    window_size = st.slider("Moving Average Window", min_value=10, max_value=max(10, max_window), value=default_window, step=10)
    
    # 1. å ±é…¬ã®æŽ¨ç§»
    st.markdown("### Reward Progress")
    
    fig_reward = make_subplots(
        rows=2, cols=1,
        subplot_titles=("Total Reward", "Reward Components"),
        vertical_spacing=0.15,
        row_heights=[0.5, 0.5]
    )
    
    # ç·å ±é…¬
    fig_reward.add_trace(
        go.Scatter(x=steps_df['total_steps'], y=steps_df['reward'],
                  mode='lines', name='Raw', opacity=0.3, line=dict(color='lightblue')),
        row=1, col=1
    )
    
    if len(steps_df) > window_size:
        ma_reward = steps_df['reward'].rolling(window=window_size).mean()
        fig_reward.add_trace(
            go.Scatter(x=steps_df['total_steps'], y=ma_reward,
                      mode='lines', name=f'MA-{window_size}', line=dict(color='blue', width=2)),
            row=1, col=1
        )
    
    # å ±é…¬ã®å†…è¨³
    if 'reward_tracking' in steps_df.columns:
        ma_tracking = steps_df['reward_tracking'].rolling(window=window_size).mean() if len(steps_df) > window_size else steps_df['reward_tracking']
        ma_stability = steps_df['reward_stability'].rolling(window=window_size).mean() if len(steps_df) > window_size else steps_df['reward_stability']
        ma_safety = steps_df['reward_safety'].rolling(window=window_size).mean() if len(steps_df) > window_size else steps_df['reward_safety']
        
        fig_reward.add_trace(
            go.Scatter(x=steps_df['total_steps'], y=ma_tracking,
                      mode='lines', name='Tracking', line=dict(color='green')),
            row=2, col=1
        )
        fig_reward.add_trace(
            go.Scatter(x=steps_df['total_steps'], y=ma_stability,
                      mode='lines', name='Stability', line=dict(color='orange')),
            row=2, col=1
        )
        fig_reward.add_trace(
            go.Scatter(x=steps_df['total_steps'], y=ma_safety,
                      mode='lines', name='Safety', line=dict(color='red')),
            row=2, col=1
        )
    
    fig_reward.update_xaxes(title_text="Steps", row=2, col=1)
    fig_reward.update_yaxes(title_text="Reward", row=1, col=1)
    fig_reward.update_yaxes(title_text="Reward Components", row=2, col=1)
    fig_reward.update_layout(height=700, showlegend=True)
    
    st.plotly_chart(fig_reward, use_container_width=True)
    
    # 2. æå¤±ã®æŽ¨ç§»
    st.markdown("### Loss Progress")
    
    # æå¤±ãŒ0ã§ãªã„ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
    valid_actor = steps_df[steps_df['actor_loss'] != 0]
    valid_critic = steps_df[steps_df['critic_loss'] != 0]
    
    if len(valid_actor) > 0 or len(valid_critic) > 0:
        fig_loss = make_subplots(
            rows=1, cols=2,
            subplot_titles=("Actor Loss", "Critic Loss"),
            horizontal_spacing=0.1
        )
        
        # Actoræå¤±
        if len(valid_actor) > 0:
            fig_loss.add_trace(
                go.Scatter(x=valid_actor['total_steps'], y=valid_actor['actor_loss'],
                          mode='lines', name='Actor (raw)', opacity=0.3, line=dict(color='lightcoral')),
                row=1, col=1
            )
            
            if len(valid_actor) > 50:
                ma_actor = valid_actor['actor_loss'].rolling(window=50).mean()
                fig_loss.add_trace(
                    go.Scatter(x=valid_actor['total_steps'], y=ma_actor,
                              mode='lines', name='Actor (MA-50)', line=dict(color='red', width=2)),
                    row=1, col=1
                )
        
        # Criticæå¤±
        if len(valid_critic) > 0:
            fig_loss.add_trace(
                go.Scatter(x=valid_critic['total_steps'], y=valid_critic['critic_loss'],
                          mode='lines', name='Critic (raw)', opacity=0.3, line=dict(color='lightgreen')),
                row=1, col=2
            )
            
            if len(valid_critic) > 50:
                ma_critic = valid_critic['critic_loss'].rolling(window=50).mean()
                fig_loss.add_trace(
                    go.Scatter(x=valid_critic['total_steps'], y=ma_critic,
                              mode='lines', name='Critic (MA-50)', line=dict(color='green', width=2)),
                    row=1, col=2
                )
        
        fig_loss.update_xaxes(title_text="Steps")
        fig_loss.update_yaxes(title_text="Loss", row=1, col=1)
        fig_loss.update_yaxes(title_text="Loss", row=1, col=2)
        fig_loss.update_layout(height=400, showlegend=True)
        
        st.plotly_chart(fig_loss, use_container_width=True)
        
        # å­¦ç¿’é–‹å§‹ã‚¹ãƒ†ãƒƒãƒ—ã®æƒ…å ±
        if len(valid_actor) > 0:
            first_learning_step = valid_actor['total_steps'].iloc[0]
            st.info(f"ðŸ’¡ Learning started at step {first_learning_step:,}")
    else:
        st.info("No learning updates yet. Waiting for buffer to fill (learning_starts threshold).")
    
    # 3. ãã®ä»–ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹
    st.markdown("### Additional Metrics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Qå€¤ã®æŽ¨ç§»
        if 'q_value' in steps_df.columns:
            fig_q = go.Figure()
            ma_q = steps_df['q_value'].rolling(window=window_size).mean() if len(steps_df) > window_size else steps_df['q_value']
            fig_q.add_trace(
                go.Scatter(x=steps_df['total_steps'], y=ma_q,
                          mode='lines', name=f'Q-value (MA-{window_size})', line=dict(color='purple'))
            )
            fig_q.update_layout(title="Q-value Progress", xaxis_title="Steps", yaxis_title="Q-value", height=300)
            st.plotly_chart(fig_q, use_container_width=True)
        
        # ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚º
        if 'buffer_size' in steps_df.columns:
            fig_buffer = go.Figure()
            fig_buffer.add_trace(
                go.Scatter(x=steps_df['total_steps'], y=steps_df['buffer_size'],
                          mode='lines', name='Buffer Size', line=dict(color='teal'))
            )
            fig_buffer.update_layout(title="Replay Buffer Size", xaxis_title="Steps", yaxis_title="Size", height=300)
            st.plotly_chart(fig_buffer, use_container_width=True)
    
    with col2:
        # åˆ¶å¾¡èª¤å·®
        error = (steps_df['target_pressure'] - steps_df['pressure']).abs()
        fig_error = go.Figure()
        ma_error = error.rolling(window=window_size).mean() if len(steps_df) > window_size else error
        fig_error.add_trace(
            go.Scatter(x=steps_df['total_steps'], y=ma_error,
                      mode='lines', name=f'Error (MA-{window_size})', line=dict(color='orange'))
        )
        fig_error.update_layout(title="Tracking Error", xaxis_title="Steps", yaxis_title="Absolute Error (m)", height=300)
        st.plotly_chart(fig_error, use_container_width=True)
        
        # ãƒãƒ«ãƒ–æ“ä½œé‡
        if 'delta_action' in steps_df.columns:
            abs_delta = steps_df['delta_action'].abs()
            fig_action = go.Figure()
            ma_action = abs_delta.rolling(window=window_size).mean() if len(steps_df) > window_size else abs_delta
            fig_action.add_trace(
                go.Scatter(x=steps_df['total_steps'], y=ma_action,
                          mode='lines', name=f'|Î”valve| (MA-{window_size})', line=dict(color='brown'))
            )
            fig_action.update_layout(title="Valve Action Magnitude", xaxis_title="Steps", yaxis_title="|Î”valve|", height=300)
            st.plotly_chart(fig_action, use_container_width=True)


def render_episode_analysis(episodes_df):
    """ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰åˆ†æžã‚’è¡¨ç¤º"""
    st.subheader("Episode-Level Analysis")
    
    # DataFrameãŒç©ºã®å ´åˆ
    if episodes_df is None or len(episodes_df) == 0:
        st.info("ðŸ“Š Episode analysis will appear here after completing at least one episode.")
        st.markdown("""
        **What you'll see here:**
        - Episode reward progression
        - MAE improvement over time
        - Learning convergence metrics
        - Control performance evolution
        """)
        return
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«
    with st.expander("ðŸ“‹ Episode Data Table", expanded=False):
        st.dataframe(episodes_df, use_container_width=True)
    
    # 1. ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰å ±é…¬ã¨MAE
    st.markdown("### Episode Performance")
    
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=("Episode Reward", "Mean Absolute Error (MAE)"),
        specs=[[{"secondary_y": False}, {"secondary_y": False}]]
    )
    
    fig.add_trace(
        go.Scatter(x=episodes_df['episode'], y=episodes_df['episode_reward'],
                  mode='lines+markers', name='Episode Reward', line=dict(color='blue')),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=episodes_df['episode'], y=episodes_df['mae'],
                  mode='lines+markers', name='MAE', line=dict(color='red')),
        row=1, col=2
    )
    
    fig.update_xaxes(title_text="Episode", row=1, col=1)
    fig.update_xaxes(title_text="Episode", row=1, col=2)
    fig.update_yaxes(title_text="Total Reward", row=1, col=1)
    fig.update_yaxes(title_text="MAE (m)", row=1, col=2)
    fig.update_layout(height=400, showlegend=False)
    
    st.plotly_chart(fig, use_container_width=True)
    
    # 2. æå¤±ã®æŽ¨ç§»
    st.markdown("### Learning Convergence")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if 'mean_actor_loss' in episodes_df.columns:
            valid_actor = episodes_df[episodes_df['mean_actor_loss'] != 0]
            if len(valid_actor) > 0:
                fig_actor = px.line(valid_actor, x='episode', y='mean_actor_loss',
                                   title='Mean Actor Loss per Episode',
                                   labels={'mean_actor_loss': 'Actor Loss', 'episode': 'Episode'})
                st.plotly_chart(fig_actor, use_container_width=True)
    
    with col2:
        if 'mean_critic_loss' in episodes_df.columns:
            valid_critic = episodes_df[episodes_df['mean_critic_loss'] != 0]
            if len(valid_critic) > 0:
                fig_critic = px.line(valid_critic, x='episode', y='mean_critic_loss',
                                    title='Mean Critic Loss per Episode',
                                    labels={'mean_critic_loss': 'Critic Loss', 'episode': 'Episode'})
                st.plotly_chart(fig_critic, use_container_width=True)
    
    # 3. åˆ¶å¾¡æ€§èƒ½ã®æŽ¨ç§»
    st.markdown("### Control Performance Evolution")
    
    fig_perf = make_subplots(
        rows=1, cols=2,
        subplot_titles=("Error Metrics", "Valve Action"),
        specs=[[{"secondary_y": True}, {"secondary_y": False}]]
    )
    
    # MAEã¨RMSE
    fig_perf.add_trace(
        go.Scatter(x=episodes_df['episode'], y=episodes_df['mae'],
                  mode='lines+markers', name='MAE', line=dict(color='orange')),
        row=1, col=1, secondary_y=False
    )
    
    if 'rmse' in episodes_df.columns:
        fig_perf.add_trace(
            go.Scatter(x=episodes_df['episode'], y=episodes_df['rmse'],
                      mode='lines+markers', name='RMSE', line=dict(color='red')),
            row=1, col=1, secondary_y=True
        )
    
    # ãƒãƒ«ãƒ–å¤‰åŒ–é‡
    if 'mean_valve_change' in episodes_df.columns:
        fig_perf.add_trace(
            go.Scatter(x=episodes_df['episode'], y=episodes_df['mean_valve_change'],
                      mode='lines+markers', name='Mean |Î”valve|', line=dict(color='brown')),
            row=1, col=2
        )
    
    fig_perf.update_xaxes(title_text="Episode")
    fig_perf.update_yaxes(title_text="MAE (m)", row=1, col=1, secondary_y=False)
    fig_perf.update_yaxes(title_text="RMSE (m)", row=1, col=1, secondary_y=True)
    fig_perf.update_yaxes(title_text="Mean |Î”valve|", row=1, col=2)
    fig_perf.update_layout(height=400)
    
    st.plotly_chart(fig_perf, use_container_width=True)


def render_detailed_metrics(steps_df, episodes_df):
    """è©³ç´°ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¡¨ç¤º"""
    st.subheader("Detailed Metrics")
    
    # çµ±è¨ˆã‚µãƒžãƒªãƒ¼
    st.markdown("### Statistical Summary")
    
    if steps_df is not None and len(steps_df) > 0:
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**Reward Statistics**")
            reward_stats = steps_df['reward'].describe()
            st.dataframe(reward_stats, use_container_width=True)
        
        with col2:
            st.markdown("**Error Statistics**")
            error = (steps_df['target_pressure'] - steps_df['pressure']).abs()
            error_stats = error.describe()
            st.dataframe(error_stats, use_container_width=True)
    else:
        st.info("ðŸ“Š Statistical summary will appear here after collecting step data.")
    
    # å­¦ç¿’ã®é€²è¡Œåº¦
    if episodes_df is not None and len(episodes_df) > 0:
        st.markdown("### Learning Progress Indicators")
        
        # æœ€è¿‘ã®æ€§èƒ½ vs åˆæœŸæ€§èƒ½
        # ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰æ•°ãŒå°‘ãªã„å ´åˆã¯å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
        num_episodes = len(episodes_df)
        window_size = min(10, num_episodes)
        
        recent_episodes = episodes_df.tail(window_size)
        early_episodes = episodes_df.head(window_size)
        
        col1, col2, col3 = st.columns(3)
        
        early_mae = early_episodes['mae'].mean()
        recent_mae = recent_episodes['mae'].mean()
        improvement_mae = ((early_mae - recent_mae) / early_mae * 100) if early_mae > 0 else 0
        
        col1.metric(f"Early MAE (first {window_size} ep.)", f"{early_mae:.3f} m")
        col2.metric(f"Recent MAE (last {window_size} ep.)", f"{recent_mae:.3f} m")
        col3.metric("Improvement", f"{improvement_mae:.1f}%", delta=f"{recent_mae - early_mae:.3f}")
        
        # å ±é…¬ã®æ”¹å–„
        early_reward = early_episodes['episode_reward'].mean()
        recent_reward = recent_episodes['episode_reward'].mean()
        improvement_reward = ((recent_reward - early_reward) / abs(early_reward) * 100) if early_reward != 0 else 0
        
        st.markdown("---")
        
        col1, col2, col3 = st.columns(3)
        col1.metric(f"Early Reward (first {window_size} ep.)", f"{early_reward:.3f}")
        col2.metric(f"Recent Reward (last {window_size} ep.)", f"{recent_reward:.3f}")
        col3.metric("Improvement", f"{improvement_reward:.1f}%", delta=f"{recent_reward - early_reward:.3f}")
    else:
        st.markdown("### Learning Progress Indicators")
        st.info("ðŸ“Š Learning progress indicators will appear here after completing multiple episodes.")
    
    # æŽ¢ç´¢ vs æ´»ç”¨
    if steps_df is not None and len(steps_df) > 0 and 'exploration' in steps_df.columns:
        st.markdown("### Exploration vs Exploitation")
        
        exploration_ratio = steps_df['exploration'].mean() * 100
        
        fig_explore = go.Figure(data=[
            go.Bar(x=['Exploration', 'Exploitation'],
                   y=[exploration_ratio, 100 - exploration_ratio],
                   marker_color=['lightblue', 'lightgreen'])
        ])
        fig_explore.update_layout(title="Exploration Ratio", yaxis_title="Percentage (%)", height=300)
        
        st.plotly_chart(fig_explore, use_container_width=True)
        
        st.info(f"ðŸ’¡ {exploration_ratio:.1f}% of steps were exploratory actions")